def primes_sieve(limit):
    a=[True]*limit
    a[0]=a[1] = False

    for (i, isprime) in enumerate(a):
        if isprime:
            yield i
            for n in range(i*i,limit, i):
                a[n]=False

                
def log(x,b):  #Because importing math is so mainstream
    if x<b:    #Obviously not incredibly accurate, but it fits these purposes incredibly well
        return 0
    else:
        return 1+log(x/b,b)

def SmallMultiple(Range):
    """
    The smallest possible number can be generated by looking at two elements:
    (1) The prime numbers in the range
    (2) The powers of primes in the range
    If the number is not prime, it does not require an additonal prime factor to generate the result.
    For example, in Project Euler's example;
    Our prime numbers are 1,2,3,5,7,11,13,17,19
    Our "powered" primes require an additional prime to be added to the list per the highest degree of the prime present in the range
    Under 20, the numbers of interest are 9,16 which add additional products 3, (2,2,2) respectively.
    The answer can thus be computed as (1*2*3*5*7*11*13*17*19 )  *  (2*2*2*3) = 232792560
    """
    b=[]
    for i in primes_sieve(Range):
        b+=[i]*log(Range,i)              #There can be no more than log (n) powers in the function
    #return reduce(lambda x,y: x*y, b)   #This has be deprecated in python 3  :(
    product = 1
    print(b)
    for i in b:
        product *=i
    return product


'''def SmallMultiple(Range):
    """
    This is the naive algorithm.  I wrote this before taking Algorithms.  Please ignore.
    """
    Range = range(1, Range+1)
    p= Range[-1]
    g= list(Range)
    for i in Range:
        a= [i*item for item in Range if item*i < p+1]
        if len(a) > 1:
            del g[g.index(a[0])]
            
    def Divisibility(Smallest,numbers):
        return all( Smallest % item ==0 for item in numbers)
    while not Divisibility(p,g):
        p+=2
    return p, g


'''
